import Foundation


/*:
 **Шаблон** в общем виде представляет собой набор некоторых инструкций, выполняя которые (следуя шаблону) обеспечивается решение определенной проблемы.
 
 **Шаблон проектирования** – это описание программной конструкции, позволяющей решить определенную типовую проблему, возникающую в ходе разработки приложения. Шаблоны описывают самые разные аспекты работы над программным кодом приложений:
   * создание объектов (порождающие шаблоны)
   * взаимодействие (поведенческие шаблоны)
   * построения архитектуры приложений в целом (структурные, или архитектурные шаблоны)
 ---
 ## Model-View-Controller
 
 ![MVC](MVC.jpg)
 
 **Model** отвечает за данные и реализацию бизнес-логики. Другими словами, к Модели относятся основные сущности и код, который их обрабатывает и реализует логику работы приложения, например, сохраняет информацию в базу данных и производит различные вычисления.
 
 **View** отвечает за графическое представление данных, а также за взаимодей- ствие с пользователем. View имеет представление только о том, каким образом данные из Модели должны отображаться на экране, и как пользователь может взаимодействовать с ними.
 
 **Controller** – это связующее звено, своеобразный клей, между Model и View. Контроллер реализует две основные функции  :
 * принимает от View команды на обновление данных и передает их в Model;
 * получает от Model извещения об изменении данных и отправляет их во View для отображения новых, обновленных.
 
 ---
 # Схема жизненного цикла View Controller
 
 ![cycle](cycle.jpg)
 
 ## Метод loadView
 Метод loadView выполняется первым в жизненном цикле. Как и viewDidLoad, он вызывается лишь один раз за все время жизни сцены. Если сцена создана с помощью Interface Builder (другим вариантом является создание элементов сцены с помощью программного кода), в данном методе производится загрузка всех размещенных на сцене графических элементов.
 
 ```
 override func loadView() { super.loadView() print("loadView")
     // Создаем метку для вывода номера версии
     let versionLabel = UILabel(frame: CGRect(x: 20, y: 10, width: 200, height: 20))

     versionLabel.text = "Версия 1.1"
     // добавляем метку в родительский view
     self.view.addSubview(versionLabel)
 }
 ```
 Метод loadView прекрасно подходит для того, чтобы создать новые графические элементы с помощью программного кода.
 
 
 ## Метод viewDidLoad aka didMount in react
 метод viewDidLoad() вызывается только один раз за всю жизнь сцены.
 
 ## Метод viewDidLoad
 Метод viewDidLoad уже был рассмотрен нами ранее. Напомню, что он вызы- вается сразу после загрузки всех отображений (всех графических элементов) и прекрасно подходит для того, чтобы внести финальные правки перед выводом сцены на экран (или другими словами, перед добавлением графических элементов в иерархию вьюшек).
 Данный метод вызывается один раз за все время жизни View Controller и сце- ны, которой он управляет.

 ## Метод viewWillAppear
 Метод viewWillAppear вызывается перед тем, как графические элементы сцены будут добавлены в иерархию графических элементов. Но в отличии от viewDidLoad он вызывается не один раз, а каждый раз, когда сцена добавляет- ся в иерархию.
 
 */


/*:

 ## Позиционирование графических элементов
 
 ![size](size.jpg)
 
 При размещении графических элементов в иерархии они должны содержать данные для их позиционирования на сцене: координаты, размеры и ограниче- ния (constraints).
 
 Очень важным является тот факт, что координаты элементов указываются относительно родительского (старшего) к нему элемента, а не от- носительно корневого.
 
 ```
 rootView
    - parentView
        -- childView
 ```
 **superview** - Графический элемент, в состав которого входит текущий элемент, называется superview. Например, parentView – это superview для childView.
 
 **subview** - Графический элемент, который входит в состав текущего, называется subview. Например, parentView – это subview для rootView.
 
 **frame** - Способ позиционирования элемента в системе координат своего superview называется frame.
 
 **bounds** – позиционирование графического элемента в своей собственной системе координат.
 
 ---
 ---
 
 
 ##  Вариант смены сцены = Методы present и dismiss
 
 ## Метод present
 
 ### СИНТАКСИС
 
 `Метод UIViewController.present(_:animated:completion:)`
 
 
 В качестве первого аргумента необходимо передать значение типа UIViewController, которое определяет, какая именно сцена должна быть отображена на экране.
 
 ### Аргументы
 
 * _: UIViewController — вьюконтроллер,который будет отображен на экране устройства.
 *  animated: Bool — флаг, указывающий на необходимость использования анимации при
 отображении элемента.
 * completion: (() -> Void)? = nil — замыкание, исполняемое после завершения вывода на экран.
 
 Пример
    `self.present(alertController, animated: true, completion: nil)`
 
 
 ## Метод dismiss
 
 Метод dismiss позволяет удалить из иерархии все графические элементы сцены. Другими словами, он выполняет противоположную методу present работу.
 
 ### СИНТАКСИС
 
 Метод `UIViewController.dismiss(animated:completion:)`
 
 Скрывает View Controller и сцену, отображение которой он обеспечивает, удаляя их из иерархии представлений.
 
 ### Аргументы
 * animated: Bool — флаг,для анимации.
 * completion: (() -> Void)? = nil —замыкание,исполняемое после скрытиясцены.
 
 `self.dismiss(animated: true, completion: nil)`
 
 
 
 */
